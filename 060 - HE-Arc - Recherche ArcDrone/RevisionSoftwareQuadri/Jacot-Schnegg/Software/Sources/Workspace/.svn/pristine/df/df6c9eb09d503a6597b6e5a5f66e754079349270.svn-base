#include <stdio.h>
#include <math.h>

#include "derivative.h" /* include peripheral declarations */
#include "mCpu.h"		/* PLL and crossbar configuration */
#include "mPwm.h"		/* FTMx configuration */
#include "mLeds.h"		/* Configuration Port leds */
#include "mRfInterface.h"
#include "stringConvert.h"
#include "iDio.h"
#include "mCapteurAccelMagn.h"
#include "mCapteurGyro.h"
#include "iSpi.h"
#include "mCapteurPression.h"
#include "iAd.h"
#include "mMesureAlimentation.h"
#include "generateTrame.h"

#define ADDRGYRO 0x69

#define kToleranceZero (float)0.055 // (% + 100) / 2000 -> 10%
void main(void)
{
	UInt16 tabReturnUInt16[kNbCapteursMax];
	float tabReturnFloat[kNbCapteursMax];
	UInt8 aVarData[kNbCapteursMax][kNbDigitsMax];
	UInt8 aVarTrame[kMaxTrameLength];

	float aVarTestFloat = 0;
	float aVarTestFloat1 = 0;
	bool aVarTestBool = false;
	UInt8 aVarTestInt = 0;
	UInt16 aVarTestUInt16 = 0;

	UInt8 aArray[12];
	float aValSent = 34.5;

	UInt32 i, j, aVarTestUInt32;

	UInt8 calibW1Addr1 = 0x1d;
	UInt8 calibW1Addr2 = 0x50;

	bool pwmUserReady = false;

	//	double magnX = 0;
	//	double magnY = 0;
	//	double magnZ = 0;
	//	double magn = 0;

	//setup interfaces	
	//-------------------------------------------------------------------------------
	iCpu_SysInit();
	iI2C_Setup();
	iUart_Config();
	iSpi_Setup();
	iPit_Config(kPit0, 2);
	iPit_StartPit(kPit0);
	iAd_Config();
	iAd_Cal(kAdc0);

	//Open interfaces	
	//-------------------------------------------------------------------------------
	iI2C_Open();
	iUart_Open();
	iSpi_Open();

	//setup modules
	//-------------------------------------------------------------------------------
	mCpu_Setup(); // PLL and crossbar configuration
	mLeds_Setup(); // Configuration Port leds
	mPwm_Setup(); // FTMx configuration
	mDelay_Setup();
	mRfInterface_Setup();
	mCapteurAccelMagn_Setup();
	//mCapteurGyro_Setup();
	mCapteurPression_Setup();

	//Open des modules
	//-------------------------------------------------------------------------------
	mDelay_Open();
	mRfInterface_Open();
	mCapteurAccelMagn_Open();
	mCapteurPression_Open();

	//Test led
	mLeds_WriteLed(kLed2, kLedOn);
	mLeds_WriteLed(kLed3, kLedOn);
	mLeds_WriteLed(kLed4, kLedOn);
	mLeds_WriteLed(kLed5, kLedOn);
	//mLeds_WriteLed(kLed6, kLedOn);
	//mLeds_WriteLed(kLed7, kLedOn);
	//mLeds_WriteLed(kLed8, kLedOn);

	//Round Robin
	while (1)
	{
		// Accéléromètre
		if (mCapteurAccelMagn_ReadAllAccelAxes(tabReturnUInt16))
		{
			stringConvert_UInt16ToChar(tabReturnUInt16[0], aVarData[0]);
			stringConvert_UInt16ToChar(tabReturnUInt16[1], aVarData[1]);
			stringConvert_UInt16ToChar(tabReturnUInt16[2], aVarData[2]);

			generateTrame(kDestAccel, kUInt16, aVarData, aVarTrame, 3);
			mRfInterface_SendString(aVarTrame);
		}

		// Magnétomètre
		if (mCapteurAccelMagn_ReadAllMagnAxes(tabReturnUInt16))
		{
			stringConvert_UInt16ToChar(tabReturnUInt16[0], aVarData[0]);
			stringConvert_UInt16ToChar(tabReturnUInt16[1], aVarData[1]);
			stringConvert_UInt16ToChar(tabReturnUInt16[2], aVarData[2]);

			//			// Attention, il faudra vérifier les valeur car le gain de Z n'est pas le même...
			//			magnX = (double)((1.3 * (Int16)tabReturnUInt16[0]) / 2048);	// 2048 et par 32768 !
			//			magnY = (double)((1.3 * (Int16)tabReturnUInt16[1]) / 2048);
			//			magnZ = (double)((1.3 * (Int16)tabReturnUInt16[2]) / 2048);
			//			magn = sqrt(magnX * magnX + magnY * magnY + magnZ * magnZ); // = 0.5 (Champs magnétique terrestre)

			generateTrame(kDestMagn, kUInt16, aVarData, aVarTrame, 3);
			mRfInterface_SendString(aVarTrame);
		}

		// Gyroscope	
//		if (mCapteurGyro_ReadAllGyroAxes(tabReturnUInt16))
//		{
//			stringConvert_UInt16ToChar(tabReturnUInt16[0], aVarData[0]);
//			stringConvert_UInt16ToChar(tabReturnUInt16[1], aVarData[1]);
//			stringConvert_UInt16ToChar(tabReturnUInt16[2], aVarData[2]);
//
//			generateTrame(kDestGyro, kUInt16, aVarData, aVarTrame, 3);
//			mRfInterface_SendString(aVarTrame);
//		}

		// Température et pression
		if (mCapteurPression_Compute())
		{
			//Température
			aVarTestFloat = mCapteurPression_ReadTemperature();
			stringConvert_FloatToChar(aVarTestFloat, aVarData[0]);

			generateTrame(kDestTemperature, kFloat, aVarData, aVarTrame, 1);
			mRfInterface_SendString(aVarTrame);

			//Pression
			aVarTestFloat = mCapteurPression_ReadPression();
			stringConvert_FloatToChar(aVarTestFloat, aVarData[0]);

			generateTrame(kDestPression, kFloat, aVarData, aVarTrame, 1);
			mRfInterface_SendString(aVarTrame);
		}

		// Tension batterie
		aVarTestFloat = mMesureAlimentation_TensionBatterie();
		stringConvert_FloatToChar(aVarTestFloat, aVarData[0]);
		generateTrame(kDestTensionAccu, kFloat, aVarData, aVarTrame, 1);
		mRfInterface_SendString(aVarTrame);

		// Courant batterie
		aVarTestFloat = mMesureAlimentation_CourantBatterie();
		stringConvert_FloatToChar(aVarTestFloat, aVarData[0]);
		generateTrame(kDestCourantAccu, kFloat, aVarData, aVarTrame, 1);
		mRfInterface_SendString(aVarTrame);

		// PWM
		tabReturnFloat[0] = mPwm_ReadSignauxTelecommande(kPwmCh0);
		tabReturnFloat[1] = mPwm_ReadSignauxTelecommande(kPwmCh1);
		tabReturnFloat[2] = mPwm_ReadSignauxTelecommande(kPwmCh2);
		tabReturnFloat[3] = mPwm_ReadSignauxTelecommande(kPwmCh3);

		if (pwmUserReady == true)
		{
			stringConvert_FloatToChar((tabReturnFloat[0] * 2000) - 100, aVarData[0]);
			stringConvert_FloatToChar((tabReturnFloat[1] * 2000) - 100, aVarData[1]);
			stringConvert_FloatToChar((tabReturnFloat[2] * 2000) - 100, aVarData[2]);
			stringConvert_FloatToChar((tabReturnFloat[3] * 2000) - 100, aVarData[3]);

			generateTrame(kDestDutyCyclePwm, kFloat, aVarData, aVarTrame, 4);
			mRfInterface_SendString(aVarTrame);

			mPwm_WriteVitesseMoteur(kPwmCh4, tabReturnFloat[0]);
			mPwm_WriteVitesseMoteur(kPwmCh5, tabReturnFloat[1]);
			mPwm_WriteVitesseMoteur(kPwmCh6, tabReturnFloat[2]);
			mPwm_WriteVitesseMoteur(kPwmCh7, tabReturnFloat[3]);
		}
		else
		{
			stringConvert_FloatToChar((kToleranceZero * 2000) - 100, aVarData[0]);
			stringConvert_FloatToChar((kToleranceZero * 2000) - 100, aVarData[1]);
			stringConvert_FloatToChar((kToleranceZero * 2000) - 100, aVarData[2]);
			stringConvert_FloatToChar((kToleranceZero * 2000) - 100, aVarData[3]);

			generateTrame(kDestDutyCyclePwm, kFloat, aVarData, aVarTrame, 4);
			mRfInterface_SendString(aVarTrame);

			mPwm_WriteVitesseMoteur(kPwmCh4, kToleranceZero);
			mPwm_WriteVitesseMoteur(kPwmCh5, kToleranceZero);
			mPwm_WriteVitesseMoteur(kPwmCh6, kToleranceZero);
			mPwm_WriteVitesseMoteur(kPwmCh7, kToleranceZero);

			if ((tabReturnFloat[0] <= kToleranceZero) && (tabReturnFloat[1] <= kToleranceZero) && (tabReturnFloat[2] <= kToleranceZero) && (tabReturnFloat[3] <= kToleranceZero))
			{
				pwmUserReady = true;

				mLeds_WriteLed(kLed6, kLedOn);
				mLeds_WriteLed(kLed7, kLedOn);
				mLeds_WriteLed(kLed8, kLedOn);
			}
		}
	}
}
